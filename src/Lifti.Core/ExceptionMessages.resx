<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AsyncAddMethodsMustBeUsed" xml:space="preserve">
    <value>When fields are configured with async access methods the async Add methods must be used on the index</value>
  </data>
  <data name="AtLeastOneFieldMustBeIndexed" xml:space="preserve">
    <value>At least one field must be configured for an item</value>
  </data>
  <data name="BatchChangeAlreadyStarted" xml:space="preserve">
    <value>Cannot start a new batch change while another is already in progress.</value>
  </data>
  <data name="CannotCombineAnEmptySetOfQueryParts" xml:space="preserve">
    <value>Cannot combine an empty set of query parts</value>
  </data>
  <data name="EarlierVersionSerializedIndexNotSupported" xml:space="preserve">
    <value>The index was serialized with binary serialization version {0} and is incompatible with this release of LIFTI.</value>
  </data>
  <data name="EmptyAdjacentTextPartsAreNotSupported" xml:space="preserve">
    <value>Adjacent text query parts cannot be empty</value>
  </data>
  <data name="EmptyBracketedExpressionsAreNotSupported" xml:space="preserve">
    <value>Bracketed query parts cannot be empty</value>
  </data>
  <data name="EmptyOrMissingTextQueryFragmentValue" xml:space="preserve">
    <value>Internal error - missing text value</value>
  </data>
  <data name="ExpectedAtLeastOneQueryPartParsed" xml:space="preserve">
    <value>Expected at least one query part to be parsed</value>
  </data>
  <data name="ExpectedFuzzyMatchToken" xml:space="preserve">
    <value>Expected a fuzzy match token - got {0}</value>
  </data>
  <data name="ExpectedTextQueryFragmentAfterMultiCharacterWildcard" xml:space="preserve">
    <value>A text fragment must follow a multi-character wildcard in a wildcard expression</value>
  </data>
  <data name="ExpectedTextToken" xml:space="preserve">
    <value>Expected a text token - got {0}</value>
  </data>
  <data name="ExpectedToken" xml:space="preserve">
    <value>Token expected: {0}</value>
  </data>
  <data name="FieldHasNoAssociatedFieldName" xml:space="preserve">
    <value>Field id {0} has no associated field name</value>
  </data>
  <data name="FieldNameAlreadyUsed" xml:space="preserve">
    <value>Duplicate field name used: {0}. Field names must be unique across all item types registered with an index.</value>
  </data>
  <data name="FieldNameMustNotBeEmpty" xml:space="preserve">
    <value>Name must not be empty</value>
  </data>
  <data name="FuzzyMatchMaxEditDistanceOutOfRange" xml:space="preserve">
    <value>Max edit distance values must be in the range 0-65535</value>
  </data>
  <data name="FuzzyMatchMaxSequentialEditsOutOfRange" xml:space="preserve">
    <value>Max sequential edit values must be in the range 0-65535</value>
  </data>
  <data name="IdAlreadyUsed" xml:space="preserve">
    <value>Id {0} is already registered in the index.</value>
  </data>
  <data name="IndexMustBeEmptyForDeserialization" xml:space="preserve">
    <value>An index must be empty when attempting to deserialize its contents.</value>
  </data>
  <data name="ItemAlreadyIndexed" xml:space="preserve">
    <value>Item already indexed</value>
  </data>
  <data name="ItemNotFound" xml:space="preserve">
    <value>Item not found</value>
  </data>
  <data name="KeyReaderMustBeProvided" xml:space="preserve">
    <value>A key reader must be specified with a call to WithKey wen configuring item tokenization options</value>
  </data>
  <data name="MalformedDataExpectedFullLocationEntry" xml:space="preserve">
    <value>Malformed index data encountered - expected a full location entry</value>
  </data>
  <data name="MalformedFuzzyMatchParameters" xml:space="preserve">
    <value>Malformed parameters for a fuzzy match operator encountered: {0}</value>
  </data>
  <data name="MaximumDistinctFieldsIndexReached" xml:space="preserve">
    <value>Only 255 distinct fields can currently be indexed</value>
  </data>
  <data name="MaxTokenLengthExceeded" xml:space="preserve">
    <value>Only tokens up to {0} characters long can be indexed.</value>
  </data>
  <data name="MissingIndexTerminator" xml:space="preserve">
    <value>The index terminator was not found at the end of the file.</value>
  </data>
  <data name="MissingLiftiHeaderIndicatorBytes" xml:space="preserve">
    <value>The expected header bytes could not be found in the stream - this is probably not a serialized index.</value>
  </data>
  <data name="NoBatchChangeInProgress" xml:space="preserve">
    <value>No batch change in progress.</value>
  </data>
  <data name="NoDeserializerAvailableForIndexVersion" xml:space="preserve">
    <value>No deserializer available for binary serialized version {0}.</value>
  </data>
  <data name="NoReaderDelegatesConfigured" xml:space="preserve">
    <value>No reader delegates configured</value>
  </data>
  <data name="NoScorerInitialized" xml:space="preserve">
    <value>Attempting to score a query result with no scorer initialized</value>
  </data>
  <data name="NotAllRequestedItemsReturned" xml:space="preserve">
    <value>Not all requested items were returned. Tme missing ids were: {0}</value>
  </data>
  <data name="NoTokenizationOptionsProvidedForType" xml:space="preserve">
    <value>No tokenization options have been provided for type {0}</value>
  </data>
  <data name="SingleCharacterWildcardsFollowingMultiCharacterNotSupported" xml:space="preserve">
    <value>Single character wildcards (%) following a multi-character wildcard (*) are not currently supported.</value>
  </data>
  <data name="TextTokensMustHaveIndexTokenizers" xml:space="preserve">
    <value>Text tokens must have an associated index tokenizer</value>
  </data>
  <data name="ThesaurusEntriesCannotResultInMultipleWords" xml:space="preserve">
    <value>Thesaurus entries cannot result in multiple words because each word will be considered equivalent which is probably not what you expect. The word was: {0} and was split into {1}</value>
  </data>
  <data name="ThesaurusEntriesMustResultInACompleteWord" xml:space="preserve">
    <value>The word "{0}" resulted in an empty value after tokenization.</value>
  </data>
  <data name="TimeoutWaitingForWriteLock" xml:space="preserve">
    <value>A timeout occurred waiting for index write lock</value>
  </data>
  <data name="UnableToEnumerateIndexedTokensAfterApplyingBookmark" xml:space="preserve">
    <value>EnumerateIndexedTokens cannot be called after applying a bookmark</value>
  </data>
  <data name="UnableToReadHeaderInformation" xml:space="preserve">
    <value>Unable to read header data from serialized index content.</value>
  </data>
  <data name="UnexpectedCloseBracket" xml:space="preserve">
    <value>Unexpected close bracket encountered in query</value>
  </data>
  <data name="UnexpectedEndOfQuery" xml:space="preserve">
    <value>The query ended unexpectedly - a token was expected.</value>
  </data>
  <data name="UnexpectedOperator" xml:space="preserve">
    <value>An unexpected operator was encountered: {0}</value>
  </data>
  <data name="UnexpectedOperatorInternal" xml:space="preserve">
    <value>Internal error - An unexpected operator was encountered: {0}</value>
  </data>
  <data name="UnexpectedOperatorParseStateEncountered" xml:space="preserve">
    <value>Unexpected OperatorParseState {0} encountered while tokenizing a query</value>
  </data>
  <data name="UnexpectedTokenEncountered" xml:space="preserve">
    <value>Unexpected token encountered: {0}</value>
  </data>
  <data name="UnknownField" xml:space="preserve">
    <value>Unknown field '{0}'</value>
  </data>
  <data name="UnknownOperatorEncountered" xml:space="preserve">
    <value>Unknown operator encountered: {0}</value>
  </data>
  <data name="UnsupportedIndexSupportLevel" xml:space="preserve">
    <value>Unsupported index support level {0}</value>
  </data>
  <data name="UnsupportedQueryJoiningOperator" xml:space="preserve">
    <value>Unsupported query joining operator: {0}</value>
  </data>
  <data name="ValueMustNotBeLessThanZero" xml:space="preserve">
    <value>Value must not be less than zero</value>
  </data>
</root>