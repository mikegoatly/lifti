<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Searching on LIFTI</title><link>https://mikegoatly.github.io/lifti/docs/searching/</link><description>Recent content in Searching on LIFTI</description><generator>Hugo</generator><language>en</language><atom:link href="https://mikegoatly.github.io/lifti/docs/searching/index.xml" rel="self" type="application/rss+xml"/><item><title>The LIFTI Query Syntax</title><link>https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/</guid><description>&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t want to use advanced queries? You&amp;rsquo;ll want to configure the &lt;a href="../simple-queries"&gt;simple query parser&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="quick-examples"&gt;Quick examples&lt;/h2&gt;
&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Example&lt;/th&gt;
 &lt;th&gt;Meaning&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;West&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;West&lt;/strong&gt; must appear in the text &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#exact-word-matches"&gt;exactly&lt;/a&gt;.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;West|Wing^2&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;West&lt;/strong&gt; or &lt;strong&gt;Wing&lt;/strong&gt; must appear in the text &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#exact-word-matches"&gt;exactly&lt;/a&gt;, where matches on &lt;strong&gt;Wing&lt;/strong&gt; will have a &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#score-boosting"&gt;score boost&lt;/a&gt; of 2.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;?Wst&lt;/td&gt;
 &lt;td&gt;Words that &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#fuzzy-match-"&gt;fuzzy match&lt;/a&gt; with &lt;strong&gt;wst&lt;/strong&gt; must appear in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;?3,2?Wst&lt;/td&gt;
 &lt;td&gt;Words that &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#fuzzy-match-"&gt;fuzzy match&lt;/a&gt; with &lt;strong&gt;wst&lt;/strong&gt; must appear in the text, with a specified max edit distance and max sequential edits.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;title=West&lt;/td&gt;
 &lt;td&gt;A &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#field-restrictions-field"&gt;field restricted&lt;/a&gt; search. &lt;strong&gt;West&lt;/strong&gt; must appear in the &lt;em&gt;&lt;strong&gt;title&lt;/strong&gt;&lt;/em&gt; field of an indexed object.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;doc*&lt;/td&gt;
 &lt;td&gt;Words that starts with &lt;strong&gt;doc&lt;/strong&gt;ument must appear in the text. &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#wildcard-matching"&gt;See wildcard matching&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;%%ing&lt;/td&gt;
 &lt;td&gt;Words that starts with any two letters and end with &lt;strong&gt;ing&lt;/strong&gt;, e.g. &lt;em&gt;doing&lt;/em&gt;. &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#wildcard-matching"&gt;See wildcard matching&lt;/a&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west &amp;amp; wing&lt;/td&gt;
 &lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#and-"&gt;and&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west wing&lt;/td&gt;
 &lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#and-"&gt;and&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text - the default operator is &amp;amp; if none is specified between search words.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west | wing&lt;/td&gt;
 &lt;td&gt;The words &lt;strong&gt;west&lt;/strong&gt; &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#or-"&gt;or&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west &amp;amp;! wing&lt;/td&gt;
 &lt;td&gt;Documents containing &lt;strong&gt;west&lt;/strong&gt; but &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#and-not-"&gt;not&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; must appear in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west ~ wing&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; and &lt;strong&gt;wing&lt;/strong&gt; must appear &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#near--and-n"&gt;near to each other&lt;/a&gt; (within 5 words - the default) in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west ~3 wing&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; and &lt;strong&gt;wing&lt;/strong&gt; must appear &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#near--and-n"&gt;near to each other&lt;/a&gt; (within &lt;strong&gt;3&lt;/strong&gt; words) in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west ~&amp;gt; wing&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must be &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#near-following--and-n"&gt;followed by&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; closely (within 5 words - the default) in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west ~3&amp;gt; wing&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must be &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#near-following--and-n"&gt;followed by&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; closely (within &lt;strong&gt;3&lt;/strong&gt; words) in the text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;west &amp;gt; wing&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#following-"&gt;precede&lt;/a&gt; &lt;strong&gt;wing&lt;/strong&gt; anywhere in the text&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&amp;ldquo;the west wing&amp;rdquo;&lt;/td&gt;
 &lt;td&gt;The words &lt;strong&gt;the west wing&lt;/strong&gt; must appear &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#sequential-text-"&gt;in sequence&lt;/a&gt; in the indexed text.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&amp;ldquo;notr* dam*&amp;rdquo;&lt;/td&gt;
 &lt;td&gt;You can use &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#wildcard-matching"&gt;wildcards&lt;/a&gt; and &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#fuzzy-match-"&gt;fuzzy matching&lt;/a&gt; in a &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#sequential-text-"&gt;sequential text&lt;/a&gt; query. In this case, a word starting with &lt;strong&gt;notr&lt;/strong&gt; must be immediately followed by a word starting with &lt;strong&gt;dam&lt;/strong&gt;, e.g. &lt;strong&gt;Notre Dame&lt;/strong&gt;.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&amp;lt;&amp;lt;west&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;west&lt;/strong&gt; must appear at the &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#start-and-end-anchors--and-"&gt;start of a the text&lt;/a&gt; (first token).&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;east&amp;gt;&amp;gt;&lt;/td&gt;
 &lt;td&gt;&lt;strong&gt;east&lt;/strong&gt; must appear at the &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#start-and-end-anchors--and-"&gt;end of the text&lt;/a&gt; (last token).&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;&amp;lt;&amp;lt;single&amp;gt;&amp;gt;&lt;/td&gt;
 &lt;td&gt;The text must contain exactly the single word &lt;strong&gt;single&lt;/strong&gt; &lt;a href="https://mikegoatly.github.io/lifti/docs/searching/lifti-query-syntax/#start-and-end-anchors--and-"&gt;and nothing else&lt;/a&gt;.&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Search terms can be combined and placed in parenthesis:&lt;/p&gt;</description></item><item><title>Query execution</title><link>https://mikegoatly.github.io/lifti/docs/searching/query-execution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/query-execution/</guid><description>&lt;p&gt;LIFTI&amp;rsquo;s query execution logic employs a strategic approach to optimize query performance, prioritizing the execution of query parts based on their calculated weights.
This weight represents the relative cost and effectiveness of executing a particular query part in relation to the overall document set. By assigning these weights,
LIFTI aims to minimize the number of documents involved early in the query execution, thereby reducing the computational load and improving efficiency.&lt;/p&gt;</description></item><item><title>Fuzzy Matching</title><link>https://mikegoatly.github.io/lifti/docs/searching/fuzzy-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/fuzzy-matching/</guid><description>&lt;p&gt;Fuzzy matches can be explicitly searched for using the &lt;a href="../lifti-query-syntax/#fuzzy-match-"&gt;LIFTI query syntax&lt;/a&gt;, or implied as the default for searches by
&lt;a href="../../index-construction/withqueryparser/#configuring-the-default-lifti-queryparser"&gt;configuring the index&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;LIFTI uses &lt;a href="https://en.wikipedia.org/wiki/Levenshtein_distance"&gt;Levenshtein distance&lt;/a&gt; to perform fuzzy matches between a search term and tokens in the index.
The distance between two words is the number of edits that are required to match them, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insertions: fid would match fi&lt;strong&gt;n&lt;/strong&gt;d&lt;/li&gt;
&lt;li&gt;deletions: foood would match food&lt;/li&gt;
&lt;li&gt;substitutions: frnd would match f&lt;strong&gt;i&lt;/strong&gt;nd&lt;/li&gt;
&lt;li&gt;transpositions: fnid would match f&lt;strong&gt;in&lt;/strong&gt;d - Transpositions are a special case, because although two characters are affected, it is considered a single edit.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The resulting Levenshtein distance between any matched term and the search term is used to reduce the score of the match. This means that documents containing
words that are closer matches will typically be surfaced higher up in the search results.&lt;/p&gt;</description></item><item><title>Simple Queries</title><link>https://mikegoatly.github.io/lifti/docs/searching/simple-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/simple-queries/</guid><description>&lt;p&gt;When you have &lt;a href="../../index-construction/withsimplequeryparser"&gt;configured an index to use the simple query parser&lt;/a&gt; you can no longer
make use of the full LIFTI query syntax in your queries, however you can still configure the simple query parser to treat all search
terms as &lt;a href="../fuzzy-matching"&gt;fuzzy matches&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Search terms are simply combined together with &lt;code&gt;and&lt;/code&gt;s or &lt;code&gt;or&lt;/code&gt;s, depending on your configuration, and punctuation is stripped out as per your
index tokenization rules.&lt;/p&gt;</description></item><item><title>Manually Constructing Queries</title><link>https://mikegoatly.github.io/lifti/docs/searching/manually-constructing-queries/</link><pubDate>Sat, 12 Feb 2022 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/manually-constructing-queries/</guid><description>&lt;p&gt;There are two approaches you can take to constructing a &lt;code&gt;Query&lt;/code&gt;, using the fluent builder syntax and manually creating the relevant query parts.&lt;/p&gt;
&lt;p&gt;The simplest is the fluent builder syntax as it takes care of automatically normalizing your search text to be in line with that expected in the index.&lt;/p&gt;
&lt;h2 id="fluent-query-building"&gt;Fluent query building&lt;/h2&gt;
&lt;p&gt;All fluent query building starts from the index:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-csharp" data-lang="csharp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Query&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;().&lt;/span&gt;&lt;span style="color:#000"&gt;ExactMatch&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can immediately execute a built query:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-csharp" data-lang="csharp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;var&lt;/span&gt; &lt;span style="color:#000"&gt;searchResults&lt;/span&gt; &lt;span style="color:#000;font-weight:bold"&gt;=&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Query&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;().&lt;/span&gt;&lt;span style="color:#000"&gt;ExactMatch&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;text&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;).&lt;/span&gt;&lt;span style="color:#000"&gt;Execute&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Or just build an &lt;code&gt;IQuery&lt;/code&gt; representing it:&lt;/p&gt;</description></item><item><title>Field Information</title><link>https://mikegoatly.github.io/lifti/docs/searching/field-information/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/field-information/</guid><description>&lt;p&gt;A &lt;code&gt;FullTextIndex&lt;/code&gt; class exposes a &lt;code&gt;FieldLookup&lt;/code&gt; property of type &lt;code&gt;IIndexedFieldLookup&lt;/code&gt; that can be used to query the index for
information about the fields that have been indexed.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IIndexedFieldLookup&lt;/code&gt; exposes the following methods:&lt;/p&gt;
&lt;h2 id="defaultfield"&gt;&lt;code&gt;DefaultField&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The id of the default field used when an &lt;code&gt;IFullTextIndex{T}.AddAsync(T, string, System.Threading.CancellationToken)&lt;/code&gt; overload has been used, as opposed to indexing text read from properties of object.&lt;/p&gt;
&lt;h2 id="getfieldforidbyte-id"&gt;&lt;code&gt;GetFieldForId(byte id)&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Gets the configured name for a field id.&lt;/p&gt;
&lt;h2 id="getfieldinfostring-fieldname"&gt;&lt;code&gt;GetFieldInfo(string fieldName)&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Gets the configuration required for indexing a named field, including the &lt;code&gt;Tokenization.TextExtraction.ITextExtractor&lt;/code&gt; and &lt;code&gt;Tokenization.IIndexTokenizer&lt;/code&gt; instances to use when processing the field&amp;rsquo;s text.&lt;/p&gt;</description></item><item><title>IndexNavigator</title><link>https://mikegoatly.github.io/lifti/docs/searching/using-the-index-navigator/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/using-the-index-navigator/</guid><description>&lt;p&gt;When processing a search query, LIFTI leverages a class called &lt;code&gt;IndexNavigator&lt;/code&gt; which allows for a character-by-character
navigation of the index.&lt;/p&gt;
&lt;p&gt;You can use an &lt;code&gt;IndexNavigator&lt;/code&gt; to do the same thing yourself. The example below demonstrates the following methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.Process&lt;/code&gt; Navigates (forward only) the nodes in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.GetExactMatches&lt;/code&gt; Gets all the matches at the current location in the index.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.GetExactAndChildMatches&lt;/code&gt; Gets the exact matches &lt;em&gt;and&lt;/em&gt; any matches in subsequent child nodes. This is the equivalent to a wildcard search.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IIndexNavigator.EnumerateIndexedTokens&lt;/code&gt; Enumerates the words (tokens) that were indexed under the current location. This essentaially allows for a reverse-engineering of words stored in the index, albeit in their index normalized form.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-csharp" data-lang="csharp"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;public&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;async&lt;/span&gt; &lt;span style="color:#000"&gt;Task&lt;/span&gt; &lt;span style="color:#000"&gt;RunAsync&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#000;font-weight:bold"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Create a full text index with default settings&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;var&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt; &lt;span style="color:#000;font-weight:bold"&gt;=&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;new&lt;/span&gt; &lt;span style="color:#000"&gt;FullTextIndexBuilder&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;string&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;&amp;gt;().&lt;/span&gt;&lt;span style="color:#000"&gt;Build&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Index some sample data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;await&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;AddAsync&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;Item1&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;,&lt;/span&gt; &lt;span style="color:#4e9a06"&gt;&amp;#34;Catastrophe&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;await&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;AddAsync&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;Item2&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;,&lt;/span&gt; &lt;span style="color:#4e9a06"&gt;&amp;#34;Casualty&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;await&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;AddAsync&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;Item3&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;,&lt;/span&gt; &lt;span style="color:#4e9a06"&gt;&amp;#34;Cat&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// To programatically search the index, create an index navigator instance &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// from the index snapshot.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;using&lt;/span&gt; &lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;var&lt;/span&gt; &lt;span style="color:#000"&gt;navigator&lt;/span&gt; &lt;span style="color:#000;font-weight:bold"&gt;=&lt;/span&gt; &lt;span style="color:#000"&gt;index&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;CreateNavigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000;font-weight:bold"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Navigate through the letters &amp;#39;C&amp;#39; and &amp;#39;A&amp;#39; (these will be the characters in their &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// *index normalized* form)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Process&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;CA&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;AsSpan&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// There will be no exact matches at the current position in the index, but 3 matches &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// when considering child matches, i.e. words starting with &amp;#34;ca&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Writes: Exact matches: 0 Exact and child matches: 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;WriteMatchState&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Navigating through the &amp;#39;T&amp;#39; of Catastrophe and Cat, but not Casualty&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Process&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#39;T&amp;#39;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Writes: Exact matches: 1 Exact and child matches: 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;WriteMatchState&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Use EnumerateIndexedTokens to reverse-engineer the words that have been indexed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// under the current location in the index, in their normalized form.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Writes:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// CAT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// CATASTROPHE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;foreach&lt;/span&gt; &lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;var&lt;/span&gt; &lt;span style="color:#000"&gt;token&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;in&lt;/span&gt; &lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;EnumerateIndexedTokens&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000;font-weight:bold"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;Console&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;WriteLine&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;token&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000;font-weight:bold"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// The Process method returns true if navigation was successful, and false otherwise:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Writes: True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;Console&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;WriteLine&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Process&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#8f5902;font-style:italic"&gt;// Writes: False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;Console&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;WriteLine&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;Process&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#34;ZOOOOM&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000;font-weight:bold"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#000;font-weight:bold"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#204a87;font-weight:bold"&gt;public&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#204a87;font-weight:bold"&gt;void&lt;/span&gt; &lt;span style="color:#000"&gt;WriteMatchState&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#000"&gt;IIndexNavigator&lt;/span&gt; &lt;span style="color:#000"&gt;navigator&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#000;font-weight:bold"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#000"&gt;Console&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;.&lt;/span&gt;&lt;span style="color:#000"&gt;WriteLine&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;(&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;$@&amp;#34;Exact matches: {navigator.GetExactMatches().Matches.Count} 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#4e9a06"&gt;Exact and child matches: {navigator.GetExactAndChildMatches().Matches.Count}&amp;#34;&lt;/span&gt;&lt;span style="color:#000;font-weight:bold"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#000;font-weight:bold"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>Understanding Query Execution Plans</title><link>https://mikegoatly.github.io/lifti/docs/searching/understanding-query-plan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mikegoatly.github.io/lifti/docs/searching/understanding-query-plan/</guid><description>&lt;h2 id="overview"&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;QueryExecutionPlan&lt;/code&gt; class represents the execution strategy for a given query. It includes information about the sequence of operations, their timings, and the number of documents affected at each stage of the query.&lt;/p&gt;
&lt;h2 id="query-execution-plan-nodes"&gt;Query execution plan nodes&lt;/h2&gt;
&lt;h3 id="node-properties"&gt;Node properties&lt;/h3&gt;
&lt;p&gt;The execution plan is structured as a tree of &lt;code&gt;QueryExecutionPlanNode&lt;/code&gt; instances, each representing a part of the query execution process. Each &lt;code&gt;QueryExecutionPlanNode&lt;/code&gt; includes details about its part of the query execution:&lt;/p&gt;</description></item></channel></rss>